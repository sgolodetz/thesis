\chapter{Implementation of Validation Features}
\label{chap:appendixval}

%##################################################################################################
\section{Drawing Tools}
%##################################################################################################

In order to allow `gold standard' reference segmentations to be produced for validation purposes, it was necessary to implement tools in \emph{millipede} to allow the user to manually draw round features of interest in 2D CT slices. Each tool can be used to replace the current selection, augment it (if the \emph{Shift} key is pressed) or subtract from it (if the \emph{Ctrl} key is pressed). Tools are classified as belonging to one of three types:
%
\begin{enumerate}
\item \emph{Instantaneous} tools, where the user clicks a point on the canvas and the selection is immediately updated (e.g.~the type of magic wand tool found in common image-editing programs).
\item \emph{Click-and-drag} tools, where the user clicks a point on the canvas, drags the mouse and then releases it to update the selection.
\item \emph{Multi-click} tools, where the user clicks a number of points and then `finalizes' the selection when ready.
\end{enumerate}
%
Three tools were implemented in \emph{millipede} (but it would be easy to add further tools if desired):
%
\begin{enumerate}

\item A click-and-drag \emph{box} tool. An example use of this is to restrict a 3D selection to a particular axial slice -- this involves switching to coronal or sagittal view and drawing boxes to remove the pieces of selection above and below the desired slice.

\item A click-and-drag \emph{lasso} tool. This can be used to draw round the exact contours of specific features, although it can require a relatively steady hand. If mistakes are made, they can be corrected fairly easily by augmenting/subtracting from the initial selection using further lassoing.

\item A multi-click \emph{line loop} tool. This involves placing a series of points to form a line loop, and then finalizing the result. Previously placed points can be dragged to new positions if mistakes are made. The line loop tool produces results that are less precise than those produced by the lasso, but it is somewhat easier to control.

\end{enumerate}
%
No instantaneous tool was implemented, because it was not essential for validation purposes, but an instantaneous magic wand tool (essentially just a single-click region growing tool) is an obvious candidate for future inclusion. A tool is implemented as a C++ class deriving from the \texttt{DrawingTool} base class shown in Listing~\ref{code:appendixval-drawingtool}. The key things to specify are:

\begin{itemize}

\item How to check whether the user is currently drawing with the tool.
\item What to do when the user presses, drags or releases the mouse. (Note from the listing that the position of the mouse when the user does any of these things is passed to the tool both in on-screen pixel coordinates and in image volume coordinates -- this will be discussed further when talking about partition forest selections later, but the essential point is that rendering is done in pixel coordinates, whereas selections must be created in image volume coordinates. Trying to produce selections by rasterizing in pixel coordinates can produce results that contain holes.)
\item How to render what is currently being drawn.
\item How to reset the tool.
\item How to evaluate the user's input to produce a selection of voxels in the image volume.
\item What style of tool this is.

\end{itemize}
%
Each of the three implemented tools is described below, after which it will be shown how they were actually used to create partition forest selections in \emph{millipede}. It should be noted that the lasso and line loop have a great deal in common, in that both create polylines that must be evaluated to produce a selection of voxels in the image volume (in the lasso case, these are large polylines that are evaluated as soon as the user releases the mouse button; in the line loop case, these are generally small polylines that are evaluated when the user requests it). The evaluation in both cases requires \emph{polyline rasterization}, which will be discussed first. In the code, both tools are implemented as subclasses of a \texttt{LineBasedDrawingTool} class, which maintains the polyline that will ultimately be fed to the rasterizer.

%---
\begin{stulisting}[p]
\caption{The DrawingTool class}
\label{code:appendixval-drawingtool}
\lstinputlisting[style=Default,language=C++]{appendixval/appendixval-drawingtool.lst}
\end{stulisting}
%---

%################################################
\subsection{Box Tool}
%################################################

The box tool is relatively straightforward to implement, as shown in Listing~\ref{code:appendixval-boxdrawingtool}. Two points are maintained to represent the extents of the box: an \emph{anchor} point and an \emph{other} point. When drawing a box, the user first presses the mouse: this initialises both points to the position of the mouse press. The user then drags the mouse, which moves the \emph{other} point away from the \emph{anchor} to make the box (see Figure~\ref{fig:appendixval-boxtool}(a)). Finally, the user releases the mouse; since the tool is not of the multi-click variety, this results in \texttt{BoxDrawingTool::selected_positions()} being called to evaluate the actual voxels contained within the box. These are initially in 2D (since the drawing tools are designed as an independent package that doesn't know about the 3D image volume), but are subsequently converted into 3D based on the slice being viewed, and used to construct a partition forest selection (see Figure~\ref{fig:appendixval-boxtool}(b)). The details of this will be described in \S\ref{subsec:appendixval-selectioninteraction}. Actually determining which voxels are in the box is a trivial process: all that is required is to traverse the box from one of its corners to the other in the obvious manner.

%---
\begin{stusubfig}{p}
	\subfigure[Before evaluating the selection]
	{\hspace{8mm}\includegraphics[height=6cm]{appendixval/appendixval-boxtool-before.png}\hspace{8mm}}%
	%
	\hspace{4mm}%
	%
	\subfigure[After evaluating the selection]
	{\hspace{8mm}\includegraphics[height=6cm]{appendixval/appendixval-boxtool-after.png}\hspace{8mm}}%
\caption{The box tool being used to select a region containing the spine}
\label{fig:appendixval-boxtool}
\end{stusubfig}
%---

%---
\begin{stulisting}[p]
\caption{The BoxDrawingTool class}
\label{code:appendixval-boxdrawingtool}
\lstinputlisting[style=Default,language=C++]{appendixval/appendixval-boxdrawingtool.lst}
\end{stulisting}
%---

%################################################
\subsection{Line-Based Tools}
%################################################

Line-based tools are those that somehow convert the user's input into a polyline (a closed line loop) and then rasterize that to determine the final selection. Precisely how the user input becomes a polyline is a matter for the individual tools (and will be discussed below), but the common work involved -- that of rendering the polyline while it is being created, and later rasterizing it to produce the selection -- is implemented in the \texttt{LineBasedDrawingTool} class (see Listing~\ref{code:appendixval-linebaseddrawingtool}) and the function \texttt{rasterize_polyline()} (see Listing~\ref{code:appendixval-rasterizepolyline}, which shows a pseudo-code, rather than C++, listing of this for increased clarity).

Rendering the polyline is essentially trivial. The \texttt{m_drawnLocations} field stores the points indicated by the user during the drawing process (each drawn location is a pair, the first component of which is the pixel location clicked, and the second component of which is the corresponding location in the image volume). The current polyline is rendered by drawing a green line strip through all the indicated points, followed by a pink line connecting the last point back to the first (this last line indicates the way in which the polyline would be automatically completed if the user stopped drawing immediately).

Polyline rasterization (which is the same problem as concave polygon rasterization) is substantially trickier, although it is a problem that has been well-studied in the past (see e.g.~\cite{heckbert90}). The basic idea is to rasterize the polyline one horizontal scanline at a time. We maintain a list of `active' edges that intersect the current scanline (every time we increment the scanline, we update the active edge list), work out where they intersect it, and then render spans of pixels between pairs of intersection points (this is known as the `even-odd parity method', because we render between intersection points $1$ and $2$, $3$ and $4$, $5$ and $6$, etc., but not between points $2$ and $3$, $4$ and $5$, etc.). What would be a relatively simple algorithm is complicated by the need to account for tricky special cases (as is common in graphics programming) such as horizontal edges. I will not attempt to describe horizontal edge handling here (it is rather outside the scope of this thesis), but the reader is encouraged to peruse the listing provided if the method is of interest.

%---
\begin{stulisting}[p]
\caption{The LineBasedDrawingTool class}
\label{code:appendixval-linebaseddrawingtool}
\lstinputlisting[style=Default,language=C++]{appendixval/appendixval-linebaseddrawingtool.lst}
\end{stulisting}
%---

%---
\begin{stulisting}[p]
\caption{Rasterizing a Polyline}
\label{code:appendixval-rasterizepolyline}
\lstinputlisting[style=Default]{appendixval/appendixval-rasterizepolyline.lst}
\end{stulisting}
%---

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsubsection{Lasso Tool}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsubsection{Line Loop Tool}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO

%################################################
\subsection{Interaction with Partition Forest Selections}
\label{subsec:appendixval-selectioninteraction}
%################################################

TODO

%##################################################################################################
\section{Feature Comparisons}
%##################################################################################################

TODO
