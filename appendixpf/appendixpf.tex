\chapter{Partition Forests -- Support Algorithms}
\label{chap:appendixpf}

%##################################################################################################
\section{The Forest Data Structure}
%##################################################################################################

%################################################
\paragraph{Ancestor Of}
%################################################

\begin{stulisting}[H]
\caption{Forest : Ancestor Of Implementation}
\begin{lstlisting}[style=Default]
function ancestor_of
:	(node : NodeID; layerIndex : int) $\to$ NodeID

	if layerIndex < node.layer() or layerIndex > highest_layer() then throw;

	var cur : NodeID := node;
	while cur.layer() < layerIndex
		var layer : IForestLayer := forest_layer(cur.layer());
		cur := NodeID(cur.layer() + 1, layer.node_parent(cur.index());
	return cur;
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Are Connected}
%################################################

\begin{stulisting}[H]
\caption{Forest : Are Connected Implementation}
\begin{lstlisting}[style=Default]
function are_connected
:	(nodes : Set<int>; layerIndex : int) $\to$ bool

	if nodes.empty() then return false;

	find_connected_component(ref nodes, layerIndex);

	// If no nodes remain after finding the first connected component, the nodes must
	// be connected, and vice-versa.
	return nodes.empty();
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Children Of}
%################################################

\begin{stulisting}[H]
\caption{Forest : Children Of Implementation}
\begin{lstlisting}[style=Default]
function children_of
:	(node : NodeID) $\to$ Set<NodeID>

	// Special case: nodes in the leaf layer have no children.
	if node.layer() = 0 then return {};

	var layer : BranchLayer? := checked_branch_layer(node.layer());
	if layer = null or not layer.has_node(node.index()) then throw;

	var result : Set<NodeID>;
	var childLayerIndex : int := node.layer() - 1;
	for each c : int $\in$ layer.node_children(node.index());
		result.insert(NodeID(childLayerIndex, c));
	return result;
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Find Common Ancestor Layer}
%################################################

\begin{stulisting}[H]
\caption{Forest : Find Common Ancestor Layer Implementation}
\begin{lstlisting}[style=Default]
function find_common_ancestor_layer
:	(component : Set<int>; layerIndex : int) $\to$ int

	var curs : Set<int> := component;
	while layerIndex $\le$ highest_layer() and curs.size() > 1
		var layer : ForestLayer := forest_layer(layerIndex);
		var parents : Set<int>;
		for each n : int $\in$ curs
			parents.insert(layer.node_parent(n));
		curs := parents;
		layerIndex := layerIndex + 1;
	return layerIndex;
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Find Common Ancestor Layer And New Chain}
%################################################

\begin{stulisting}[H]
\caption{Forest : Find Common Ancestor Layer And New Chain Implementation}
\begin{lstlisting}[style=Default]
function find_common_ancestor_layer_and_new_chain
:	(oldParent : int; newParent : int; layerIndex : int) $\to$ (int,Chain)

	var newChain : Chain;
	var curOld, curNew : int := oldParent, newParent;
	while layerIndex $\le$ highest_layer() and curOld $\ne$ curNew
		newChain.push_front(NodeID(layerIndex, curNew));
		var layer : ForestLayer := forest_layer(layerIndex);
		curOld := layer.node_parent(curOld);
		curNew := layer.node_parent(curNew);
		layerIndex := layerIndex + 1;
	return (layerIndex, newChain);
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Find Connected Component}
%################################################

\begin{stulisting}[H]
\caption{Forest : Find Connected Component Implementation}
\begin{lstlisting}[style=Default]
function find_connected_component
:	(nodes : ref Set<int>; layerIndex : int) $\to$ Set<int>

	var result : Set<int>;
	var layer : ForestLayer := forest_layer(layerIndex);
	var seed : int := lowest_int(nodes);
	nodes.erase(seed);

	var q : Queue<int>;
	q.push(seed);
	while not q.empty()
		var n : int := q.pop();
		result.insert(n);
		for each e : Edge $\in$ layer.adjacent_edges(n)
			var other : int := other_end(e, n);
			if nodes.contains(other) then
				q.push(other);
				nodes.erase(other);
	return result;
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Find Connected Components}
%################################################

\begin{stulisting}[H]
\caption{Forest : Find Connected Components Implementation}
\begin{lstlisting}[style=Default]
function find_connected_components
:	(nodes : Set<int>; layerIndex : int) $\to$ Vector<Set<int>>

	var result : Vector<Set<int>>;
	while not nodes.empty()
		result.push_back(find_connected_component(nodes, layerIndex));
	return result;
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Receptive Region Of}
%################################################

\begin{stulisting}[H]
\caption{Forest : Receptive Region Of Implementation}
\begin{lstlisting}[style=Default]
function receptive_region_of : (node : NodeID) $\to$ Deque<int>
	var MARKER : int := -1;
	var layerIndex : int := node.layer();
	var nodeIndices : Deque<int> := [node.index(), MARKER];
	while layerIndex $>$ 0
		var layer : BranchLayer := branch_layer(layerIndex);
		while true	// iterate until a break occurs
			var n : int := nodeIndices.front();
			nodeIndices.pop_front();
			if n = MARKER then break;
			nodeIndices.append(layer.node_children(n));
		nodeIndices.push_back(MARKER);
		layerIndex := layerIndex - 1;
	nodeIndices.pop_back();
	return nodeIndices;
\end{lstlisting}
\end{stulisting}

%##################################################################################################
\section{The Selection Data Structure}
%##################################################################################################

%################################################
\paragraph{Clear}
%################################################

TODO

%################################################
\paragraph{Combine}
%################################################

TODO

%################################################
\paragraph{Combine Using Leaves}
%################################################

TODO

%################################################
\paragraph{Consolidate All}
%################################################

\begin{stulisting}[H]
\caption{Selection : Consolidate All Implementation}
\begin{lstlisting}[style=Default]
function consolidate_all : () $\to$ $\emptyset$
	for i : int := 0 up to forest().highest_layer() - 1
		var parents : Set<NodeID>;
		for each n $\in$ layer(i)
			parents.insert(forest().parent_of(NodeID(i,n)));
		for each p $\in$ parents
			consolidate_node(p, null);
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Consolidate Node}
%################################################

\begin{stulisting}[H]
\caption{Selection : Consolidate Node Implementation}
\begin{lstlisting}[style=Default]
function consolidate_node : (node : NodeID; modification : ref Modification?) $\to$ bool
	// Check to see if all the children of the specified node are selected.
	for each c $\in$ forest().children_of(node)
		if not in_representation(c) then return false;

	// If they are, deselect them and select this node instead.
	for each c $\in$ forest().children_of(node)
		erase_node(c, ref modification);
	insert_node(node, ref modification);

	listeners.node_was_consolidated(node);
	return true;
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Consolidate Upwards From Node}
%################################################

\begin{stulisting}[H]
\caption{Selection : Consolidate Upwards From Node Implementation}
\begin{lstlisting}[style=Default]
function consolidate_upwards_from_node : (node : NodeID; modification : ref Modification?) $\to$ $\emptyset$
	var cur : NodeID := node;
	while not cur.invalid() and consolidate_node(cur, ref modification)
		cur := forest().parent_of(cur);
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Constructor (Unique Leaves)}
%################################################

TODO

%################################################
\paragraph{Contains}
%################################################

TODO

%################################################
\paragraph{Deconsolidate Node}
%################################################

\begin{stulisting}[H]
\caption{Selection : Deconsolidate Node Implementation}
\begin{lstlisting}[style=Default]
function deconsolidate_node : (node : NodeID; modification : ref Modification?) $\to$ $\emptyset$
	// Replace the selected node with its children in the forest.
	erase_node(node, ref modification);
	for each c $\in$ forest().children_of(node)
		insert_node(c, ref modification);
	listeners.node_was_deconsolidated(node);
\end{lstlisting}
\end{stulisting}

%################################################
\paragraph{Descendants In Layer}
%################################################

TODO

%################################################
\paragraph{Descendants In Representation}
%################################################

TODO

%################################################
\paragraph{Empty}
%################################################

TODO

%################################################
\paragraph{Erase Node}
%################################################

TODO

%################################################
\paragraph{Find Ancestor In Representation}
%################################################

TODO

%################################################
\paragraph{In Representation}
%################################################

TODO

%################################################
\paragraph{Insert Node}
%################################################

TODO

%################################################
\paragraph{Merge Layer}
%################################################

TODO

%################################################
\paragraph{Replace With Selection}
%################################################

TODO

%################################################
\paragraph{Split Selection}
%################################################

TODO

%################################################
\paragraph{Subtract}
%################################################

TODO

%################################################
\paragraph{Subtract Using Leaves}
%################################################

TODO

%################################################
\paragraph{Toggle Node}
%################################################

TODO

%################################################
\paragraph{View At Layer (Iterator Version)}
%################################################

TODO

%##################################################################################################
\section{The Multi-Feature Selection Data Structure}
%##################################################################################################

%################################################
\paragraph{Clear All}
%################################################

TODO

%################################################
\paragraph{Clear Feature}
%################################################

TODO

%################################################
\paragraph{Combine}
%################################################

TODO

%################################################
\paragraph{Empty}
%################################################

TODO

%################################################
\paragraph{Features Of}
%################################################

TODO

%################################################
\paragraph{Identify Multi-Feature Selection}
%################################################

TODO

%################################################
\paragraph{Identify Node}
%################################################

TODO

%################################################
\paragraph{Identify Selection}
%################################################

TODO

%################################################
\paragraph{Subtract}
%################################################

TODO

%################################################
\paragraph{Toggle Node}
%################################################

TODO

%################################################
\paragraph{Toggle Selection}
%################################################

TODO

%################################################
\paragraph{Unidentify Node}
%################################################

TODO

%################################################
\paragraph{Unidentify Selection}
%################################################

TODO
