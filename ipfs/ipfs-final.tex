\chapter{Principles of Image Partition Forests}
\label{chap:ipfs}

%---
\section{Chapter Overview}

In Chapter~\ref{chap:methodology}, I discussed the goals of my doctorate and the methods I chose to try to achieve them. This chapter introduces partition forests as a data structure, along with a set of novel algorithms for working with them. It further explains how the partition forest data structure can be applied in the imaging domain. In that context, we will talk of partition forests as image partition forests (or IPFs). This lays the foundation for the two following chapters, which describe how IPFs can be constructed from images (Chapter~\ref{chap:segmentation}) and then used to identify features therein (Chapter~\ref{chap:featureid}).

As will be discussed in Chapter~\ref{chap:assessment}, however, the partition forest data structure and its accompanying algorithms are useful in a wider context than just imaging. In particular, we will later see another application of partition forests in the domain of hierarchical pathfinding.

%---
\section{What is a Partition Forest?}

\subsection{Concept}

A partition forest is in essence a hierarchy of adjacency graphs that all partition the same object (the sense in which a graph can partition an object will be formalised in what follows). The object itself can be anything that can be divided into pieces, whether that be an image, a road network, an organisation, or even a pizza. Partition forests as a data structure are similar to the picture trees described in \cite{andrade03}. They are also related to the semantic segmentation trees found in \cite{al-haj08} and the binary partition trees found in \cite{salembier00}. The partition forest algorithms I will describe in \S\ref{sec:ipfs-algorithms}, however, are entirely novel.

The ideas behind partition forests can be most simply illustrated using the aforementioned example of a pizza (see Figure~\ref{fig:ipfs-pizza}). We consider three different levels of partitioning for the pizza: into slices, into portions, and into halves (e.g.~a vegetarian half and a meat half). Each half contains one or more portions and each portion contains one or more slices. All the slices taken together form the whole pizza, and none of them mutually overlap. This is equally true for both the portions and the halves. Taken together, the slices, portions and halves (the `pieces') form a hierarchy of partitions of the pizza, in which the individual pieces become nodes. (Note that the top-most level of the hierarchy is allowed to contain more than one node -- this is what makes the hierarchy a forest rather than a tree.) Each level of the hierarchy is an adjacency graph: in this case, the adjacency graphs for the slices and portions form rings (each slice/portion is adjacent to the slices/portions on either side of it), whilst the adjacency graph for the halves is just a single edge between them. The weights on the edges are not especially important in the case of pizzas (we could perhaps imagine them as indicating the ease of pulling the pizza apart at that point, if we wanted to push the analogy), but they are very important in the imaging domain, as we will see later.

%---
% TODO: fig:ipfs-pizza
\stufigex{width=15cm, height=24cm}{todo.png}{TODO}{fig:ipfs-pizza}{p}
%---

It is rare for pizza slices and portions to all be identical -- some slices will generally end up with more topping on than others, and some portions may contain more slices than others. When identifying an appropriate portion to choose, therefore, it is important to have relevant properties of the slices and portions available in order to make an informed choice. For that purpose, we can attach properties to the nodes of the forest that provide this information for later use. These properties can be different for different node layers. We can imagine maintaining a topping quality property for slices, with perhaps slice count and best/average topping quality properties for portions. What is important is that the properties of each node can be calculated directly from those of its children in the hierarchy. In this case, that would mean that the properties of a portion should be a function of only the properties of the slices in that portion.

\subsection{Definition}

Abstracting away from the intuitive description of partition forests just given, it is possible to define them more formally as follows:

\begin{definition}
An \textbf{object} is a non-empty set of basic components which together form a contiguous whole. (For example, a contiguous image region would be a non-empty set of pixels.)
\end{definition}

\begin{definition}
A set of k objects $\{o'_1,\ldots,o'_k\}$ \textbf{partitions} an object $o$ iff $\bigcup_i o'_i = o$ and $\forall i,j \cdot o'_i \cap o'_j = \emptyset$. We write the relation as $\mathcal{P}(\{o'_1,\ldots,o'_k\}, o)$.
\end{definition}

\begin{definition}
Given an object $o$, and two objects sets $O'_f = \{o'_{f1},\ldots,o'_{fk_f}\}$ and $O'_c = \{o'_{c1},\ldots,o'_{ck_c}\}$, satisfying $\mathcal{P}(O'_f,o)$ and $\mathcal{P}(O'_c,o)$, we say that $O'_c$ is a \textbf{coarser partition} of $o$ than $O'_f$ (written $O'_f \sqsubseteq O'_c$) iff for every object $o'_{ci} \in O'_c$ there exists a subset $S_i \subseteq O'_f$ such that $\mathcal{P}(S_i,o'_{ci})$. (In other words, $O'_f$ is a partition of $o$ in which each individual object in $O'_c$ has itself been partitioned.)
\end{definition}

\begin{definition}
Letting $\mbox{adj}_o(o'_i, o'_j)$ denote that sub-objects $o'_i$ and $o'_j$ are (in some sense) adjacent in an object $o$, we define a \textbf{weight function} $w_o$ for $o$ to be a function of type $\mathbb{P}(o) \times \mathbb{P}(o) \to \mathbb{R}^+$ that satisfies the following two requirements:
%
\begin{enumerate}

\item $w_o(o'_i, o'_j) \ne \infty$ when, and only when, $adj_o(o'_i, o'_j)$ is true

\item Given any sets $S_i$ and $S_j$ satisfying $\mathcal{P}(S_i,o'_i)$ and $\mathcal{P}(S_j,o'_j)$, the value $w_o(o'_i, o'_j)$ is a function of only the values in the set $\{w_o(s_i, s_j) \; | \; s_i \leftarrow S_i, \; s_j \leftarrow S_j\}$.

\end{enumerate}

\end{definition}

\begin{definition}
A \textbf{property set} is an ordered set (a tuple) of properties, each of which is a function that maps an object to a value (the types of the values may differ). For example, in the context of imaging it would be possible to have an area property that calculates the area of a given image region in pixels.
\end{definition}

\begin{definition}
Given a property set $P = (p_1,\ldots,p_k)$ and an object $o$, the \textbf{property value set} $V_P(o)$ is the ordered set that results from applying each property in $P$ to the object $o$, namely $(p_1(o),\ldots,p_k(o))$.
\end{definition}

\begin{definition}
We call a property set $P$ \textbf{directly calculable} from a property set $P'$ iff, for any given set of sub-objects $O'$ and object $o$ satisfying $\mathcal{P}(O',o)$, the property value set $V_P(o)$ is a function of only the property value sets in $\{V_{P'}(o') \; | \; o' \in O'\}$. We write this relation as $P' \hookrightarrow P$.
\end{definition}

\begin{definition}
A \textbf{partition node} is a node in a partition forest. Each node $n$ represents a given object, denoted as $\mbox{obj}(n)$. The set of objects represented by a node set $N$ can be denoted as $\mbox{Objs}(N)$.
\end{definition}

\begin{definition}
A \textbf{partitioning graph} $G(N,w_o,P)$ of an object $o$ is an undirected graph with weighted edges and property values on each node. It has ordered node set $N$, satisfying $\mathcal{P}(\mbox{Objs}(N),o)$, edge set $E = \{(n_i,n_j,w(\mbox{obj}(n_i),\mbox{obj}(n_j))) \; | \; n_i, n_j \leftarrow N\}$, and property value set tuple $VS = (V_P(\mbox{obj}(n)) \; | \; n \leftarrow N)$.
\end{definition}

\begin{definition}
Given an object $o$, a tuple $NS = (N_1,\ldots,N_k)$, where $\forall N_i \in NS \cdot \mathcal{P}(\mbox{Objs}(N_i),o)$ and $\mbox{Objs}(N_1) \sqsubseteq \ldots \sqsubseteq \mbox{Objs}(N_k)$, a weight function $w_o$ for $o$ and a tuple $PS = (P_1,\ldots,P_k)$ satisfying $P_1 \hookrightarrow \ldots \hookrightarrow P_k$, we define the \textbf{partition forest} $PF_{NS,w_o,PS}(o)$ to be the pair $(FL,PG)$, in which:

\begin{itemize}

\item $FL$ is a set of forest links, defined as:
%
\[
\{(n_c,n_p) \; | \; n_c, n_p \leftarrow N_1,\ldots,N_k \mbox{ and } n_c \ne n_p \mbox{ and } \mbox{obj}(n_c) \subseteq \mbox{obj}(n_p)\}
\]

\item $GS$ is an ordered set of partitioning graphs of $o$, defined as:
%
\[
(G(N_1,w_o,P_1),\ldots,G(N_k,w_o,P_k))
\]

\end{itemize}

\noindent We can also define a parent/child relation between nodes, namely that $p = \mbox{parent}(c)$ and $c \in \mbox{children}(p)$ iff $(c,p) \in FL$.

\end{definition}

%---
\section{Partition Forest Algorithms}
\label{sec:ipfs-algorithms}

\subsection{Overview}

TODO

\subsection{Modification Algorithms}

\subsubsection{Overview}

TODO

\subsubsection{Core Algorithms}

\paragraph{Layer Creation}

TODO

\paragraph{Layer Deletion}

TODO

\paragraph{Node Splitting}

TODO

\paragraph{Sibling Node Merging}

TODO

\subsubsection{Zipping Algorithms}

\paragraph{Unzipping}

TODO

\paragraph{Zipping}

TODO

\subsubsection{Higher-Level Algorithms}

\paragraph{Arbitrary Node Merging}

TODO

\paragraph{Parent Switching}

TODO

\subsubsection{Applied Algorithms}

\paragraph{Feature Identification}

TODO

\subsection{Selection Algorithms}

\subsubsection{Overview}

TODO

\subsubsection{Add To Selection}

TODO

\subsubsection{Remove From Selection}

TODO

\subsubsection{View Selection At Layer}

TODO

%---
\section{Image Partition Forests}

TODO

%---
\section{Chapter Summary}

TODO
